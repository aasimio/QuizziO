# Task 4.2: Scan Papers Page - Implementation Plan

## Overview
Implement Screen 5 (Scan Papers Page) - a camera-based OMR scanning interface that displays live camera preview with alignment guides, processes answer sheets through the OMR pipeline, and shows scan results.

## Prerequisites
- [x] Task 4.1 ScannerBloc State Machine - Complete (8-state machine implemented)

---

## Files to Create/Modify

### New Files
| File | Purpose |
|------|---------|
| `lib/features/omr/presentation/widgets/alignment_overlay.dart` | 4-corner marker detection overlay with visual feedback |
| `lib/features/omr/presentation/widgets/scan_bottom_bar.dart` | Bottom bar with scan count and manual capture button |
| `lib/features/omr/presentation/widgets/processing_overlay.dart` | Semi-transparent processing indicator |
| `lib/features/omr/presentation/widgets/scan_result_popup.dart` | Result display (placeholder for Task 4.4) |

### Modified Files
| File | Changes |
|------|---------|
| `lib/features/omr/presentation/pages/scan_papers_page.dart` | Complete rewrite from stub |
| `lib/features/quiz/presentation/pages/quiz_menu_page.dart` | Update navigation to pass full Quiz object |

---

## Detailed Implementation Steps

### Step 1: Update ScanPapersArgs

**File:** `lib/features/omr/presentation/pages/scan_papers_page.dart`

The current stub uses `quizId` and `quizName`, but `ScannerBloc.ScannerInitCamera` requires a full `Quiz` object. Update the args:

```dart
import '../../../quiz/domain/entities/quiz.dart';

class ScanPapersArgs {
  final Quiz quiz;

  const ScanPapersArgs({required this.quiz});

  // Convenience getters for backward compatibility
  String get quizId => quiz.id;
  String get quizName => quiz.name;
}
```

---

### Step 2: Create AlignmentOverlay Widget

**File:** `lib/features/omr/presentation/widgets/alignment_overlay.dart`

This widget renders 4 L-shaped corner brackets that indicate marker detection status.

#### Props
```dart
class AlignmentOverlay extends StatefulWidget {
  final int markersDetected;      // 0-4 markers currently detected
  final bool isAligning;          // true when all 4 found and stabilizing
  final int stabilityMs;          // 0-500ms progress toward auto-capture

  const AlignmentOverlay({
    super.key,
    required this.markersDetected,
    this.isAligning = false,
    this.stabilityMs = 0,
  });
}
```

#### Visual Specifications

**Corner Brackets (L-shapes):**
- Size: 60x60dp per corner
- Stroke width: 4dp
- Rounded corner radius: 8dp on outer edges
- Position: 24dp inset from screen edges

**State Colors:**
```dart
// Colors from quizzio-flutter-design skill
const notDetectedColor = Color(0xFFFF6B6B);  // Warm coral - pulsing
const detectedColor = Color(0xFF4ECDC4);      // Soft mint - solid
const aligningColor = Color(0xFF2ECC71);      // Brighter green when all aligned
```

**Animations:**
```dart
// Pulsing animation for undetected corners
// Duration: 600ms
// Opacity: 0.4 -> 1.0
// Curve: Curves.easeInOut
// Repeat: infinite while not detected

AnimatedOpacity(
  opacity: _isPulsing ? 0.4 : 1.0,
  duration: const Duration(milliseconds: 600),
  curve: Curves.easeInOut,
  child: CornerBracket(...),
)
```

**Center Instruction Text:**
- When previewing: "Point camera at answer sheet"
- When aligning: "Hold steady..." (with subtle pulse)

**Stability Progress Ring (when isAligning == true):**
- Centered circular progress indicator
- 80dp diameter, 4dp stroke
- Shows stabilityMs / 500 fill
- Teal to green gradient

#### Implementation Structure
```dart
class AlignmentOverlay extends StatefulWidget { ... }

class _AlignmentOverlayState extends State<AlignmentOverlay>
    with SingleTickerProviderStateMixin {
  late AnimationController _pulseController;
  late Animation<double> _pulseAnimation;

  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    )..repeat(reverse: true);

    _pulseAnimation = Tween<double>(begin: 0.4, end: 1.0).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // Top-left corner
        Positioned(
          top: 24,
          left: 24,
          child: _CornerBracket(
            corner: Corner.topLeft,
            isDetected: _isCornerDetected(0),
            pulseAnimation: _pulseAnimation,
          ),
        ),
        // Top-right corner
        Positioned(
          top: 24,
          right: 24,
          child: _CornerBracket(
            corner: Corner.topRight,
            isDetected: _isCornerDetected(1),
            pulseAnimation: _pulseAnimation,
          ),
        ),
        // Bottom-right corner
        Positioned(
          bottom: 104, // Above bottom bar
          right: 24,
          child: _CornerBracket(
            corner: Corner.bottomRight,
            isDetected: _isCornerDetected(2),
            pulseAnimation: _pulseAnimation,
          ),
        ),
        // Bottom-left corner
        Positioned(
          bottom: 104,
          left: 24,
          child: _CornerBracket(
            corner: Corner.bottomLeft,
            isDetected: _isCornerDetected(3),
            pulseAnimation: _pulseAnimation,
          ),
        ),
        // Center instruction text
        Center(
          child: _InstructionText(
            isAligning: widget.isAligning,
            stabilityMs: widget.stabilityMs,
          ),
        ),
        // Stability progress ring (when aligning)
        if (widget.isAligning)
          Center(
            child: _StabilityProgressRing(
              progress: widget.stabilityMs / 500.0,
            ),
          ),
      ],
    );
  }
}
```

---

### Step 3: Create ScanBottomBar Widget

**File:** `lib/features/omr/presentation/widgets/scan_bottom_bar.dart`

A bottom bar showing scan count and manual capture button.

#### Props
```dart
class ScanBottomBar extends StatelessWidget {
  final int scannedCount;
  final bool canCapture;          // enabled when markersDetected == 4
  final VoidCallback? onManualCapture;

  const ScanBottomBar({
    super.key,
    required this.scannedCount,
    required this.canCapture,
    this.onManualCapture,
  });
}
```

#### Visual Layout
```
+----------------------------------------------------------+
|  [checkmark] Scanned: 5              [CAPTURE BUTTON]    |
+----------------------------------------------------------+
```

#### Specifications
```dart
Container(
  height: 80,
  padding: const EdgeInsets.symmetric(horizontal: 24),
  decoration: BoxDecoration(
    color: colorScheme.surface,
    borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
    boxShadow: [
      BoxShadow(
        color: Colors.black.withOpacity(0.1),
        blurRadius: 10,
        offset: const Offset(0, -4),
      ),
    ],
  ),
  child: Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      // Scan count
      Row(
        children: [
          Icon(Icons.check_circle_outline, color: Color(0xFF0D7377)),
          const SizedBox(width: 8),
          Text('Scanned: $scannedCount', style: GoogleFonts.dmSans(fontSize: 16)),
        ],
      ),
      // Capture button
      _CaptureButton(
        enabled: canCapture,
        onPressed: onManualCapture,
      ),
    ],
  ),
)
```

**Capture Button:**
- Size: 64dp circular (exceeds 48dp touch target)
- Icon: `Icons.camera` or custom shutter icon
- Background: Primary teal (#0D7377) when enabled, gray when disabled
- Ripple effect on press

---

### Step 4: Create ProcessingOverlay Widget

**File:** `lib/features/omr/presentation/widgets/processing_overlay.dart`

Semi-transparent overlay with spinner and status text during OMR processing.

#### Props
```dart
class ProcessingOverlay extends StatelessWidget {
  final String status;  // e.g., "Detecting markers...", "Grading answers..."

  const ProcessingOverlay({
    super.key,
    required this.status,
  });
}
```

#### Implementation
```dart
@override
Widget build(BuildContext context) {
  return Container(
    color: Colors.black.withOpacity(0.6),
    child: Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(
            color: Colors.white,
            strokeWidth: 3,
          ),
          const SizedBox(height: 24),
          Text(
            status,
            style: GoogleFonts.dmSans(
              fontSize: 16,
              color: Colors.white,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    ),
  );
}
```

**Entry Animation:**
- Fade in from 0 to 60% opacity
- Scale from 0.8 to 1.0
- Duration: 300ms
- Curve: Curves.easeOutCubic

---

### Step 5: Create ScanResultPopup Placeholder

**File:** `lib/features/omr/presentation/widgets/scan_result_popup.dart`

Basic structure for Task 4.4 to expand.

#### Props
```dart
class ScanResultPopup extends StatelessWidget {
  final ScanResult scanResult;
  final int processingTimeMs;
  final VoidCallback onContinue;      // Dismiss and resume scanning
  final VoidCallback onViewDetails;   // Navigate to detail page

  const ScanResultPopup({
    super.key,
    required this.scanResult,
    required this.processingTimeMs,
    required this.onContinue,
    required this.onViewDetails,
  });
}
```

#### Basic Implementation (placeholder for 4.4)
```dart
@override
Widget build(BuildContext context) {
  final colorScheme = Theme.of(context).colorScheme;

  return Container(
    padding: const EdgeInsets.all(24),
    decoration: BoxDecoration(
      color: colorScheme.surface,
      borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
    ),
    child: Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Handle bar
        Container(
          width: 40,
          height: 4,
          decoration: BoxDecoration(
            color: colorScheme.outlineVariant,
            borderRadius: BorderRadius.circular(2),
          ),
        ),
        const SizedBox(height: 24),

        // Score display
        Text(
          '${scanResult.score}/${scanResult.total}',
          style: GoogleFonts.outfit(
            fontSize: 48,
            fontWeight: FontWeight.bold,
            color: _getScoreColor(scanResult.percentage),
          ),
        ),
        Text(
          '${(scanResult.percentage * 100).toStringAsFixed(0)}%',
          style: GoogleFonts.dmSans(
            fontSize: 20,
            color: colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Processed in ${(processingTimeMs / 1000).toStringAsFixed(1)}s',
          style: GoogleFonts.dmSans(
            fontSize: 14,
            color: colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 24),

        // Action buttons
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: onViewDetails,
                child: Text('View Details'),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: FilledButton(
                onPressed: onContinue,
                child: Text('Continue'),
              ),
            ),
          ],
        ),
        SizedBox(height: MediaQuery.of(context).padding.bottom + 16),
      ],
    ),
  );
}

Color _getScoreColor(double percentage) {
  if (percentage >= 0.8) return const Color(0xFF4ECDC4);  // Green
  if (percentage >= 0.5) return Colors.amber;              // Amber
  return const Color(0xFFFF6B6B);                          // Red
}
```

**Show as modal bottom sheet:**
```dart
void _showResultPopup(BuildContext context, ScannerResult state) {
  showModalBottomSheet(
    context: context,
    isDismissible: false,
    enableDrag: false,
    isScrollControlled: true,
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
    ),
    builder: (_) => ScanResultPopup(
      scanResult: state.scanResult,
      processingTimeMs: state.processingTimeMs,
      onContinue: () {
        Navigator.pop(context);
        context.read<ScannerBloc>().add(const ScannerResultDismissed());
      },
      onViewDetails: () {
        Navigator.pop(context);
        Navigator.pushNamed(
          context,
          AppRoutes.scanResultDetail,
          arguments: ScanResultDetailArgs(scanResult: state.scanResult),
        );
      },
    ),
  );
}
```

---

### Step 6: Implement ScanPapersPage

**File:** `lib/features/omr/presentation/pages/scan_papers_page.dart`

Complete rewrite of the stub.

#### Widget Structure
```
ScanPapersPage (StatelessWidget)
  └── BlocProvider<ScannerBloc>
        └── _ScanPapersContent (StatefulWidget with WidgetsBindingObserver)
              └── WillPopScope (handle back navigation)
                    └── Scaffold
                          ├── AppBar
                          │     ├── Leading: back button (automatic)
                          │     ├── Title: "Scan Papers"
                          │     └── Actions: [FlashToggleButton]
                          └── Body: Stack
                                ├── BlocConsumer<ScannerBloc, ScannerState>
                                │     └── switch (state) { ... }
                                └── Positioned.bottom: ScanBottomBar
```

#### Full Implementation

```dart
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:get_it/get_it.dart';
import 'package:google_fonts/google_fonts.dart';

import '../../../../core/constants/app_constants.dart';
import '../../../../core/services/camera_service.dart';
import '../../../../injection.dart';
import '../../../quiz/domain/entities/quiz.dart';
import '../../domain/entities/scan_result.dart';
import '../bloc/scanner_bloc.dart';
import '../bloc/scanner_event.dart';
import '../bloc/scanner_state.dart';
import '../widgets/alignment_overlay.dart';
import '../widgets/processing_overlay.dart';
import '../widgets/scan_bottom_bar.dart';
import '../widgets/scan_result_popup.dart';

class ScanPapersArgs {
  final Quiz quiz;

  const ScanPapersArgs({required this.quiz});

  String get quizId => quiz.id;
  String get quizName => quiz.name;
}

class ScanPapersPage extends StatelessWidget {
  final ScanPapersArgs? args;

  const ScanPapersPage({super.key, this.args});

  @override
  Widget build(BuildContext context) {
    if (args == null) {
      return _ErrorScaffold(message: 'Missing quiz arguments');
    }

    return BlocProvider<ScannerBloc>(
      create: (_) => getIt<ScannerBloc>()
        ..add(ScannerInitCamera(quiz: args!.quiz)),
      child: _ScanPapersContent(quiz: args!.quiz),
    );
  }
}

class _ScanPapersContent extends StatefulWidget {
  final Quiz quiz;

  const _ScanPapersContent({required this.quiz});

  @override
  State<_ScanPapersContent> createState() => _ScanPapersContentState();
}

class _ScanPapersContentState extends State<_ScanPapersContent>
    with WidgetsBindingObserver {
  bool _flashOn = false;
  int _scannedCount = 0;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // Camera cleanup handled by ScannerBloc
    if (state == AppLifecycleState.resumed) {
      // Optionally re-check camera state
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: Colors.black,
        appBar: AppBar(
          title: Text(
            'Scan Papers',
            style: GoogleFonts.outfit(
              fontSize: 20,
              fontWeight: FontWeight.w600,
            ),
          ),
          backgroundColor: Colors.transparent,
          foregroundColor: Colors.white,
          elevation: 0,
          actions: [
            _FlashToggleButton(
              isOn: _flashOn,
              onToggle: _toggleFlash,
            ),
          ],
        ),
        extendBodyBehindAppBar: true,
        body: Stack(
          fit: StackFit.expand,
          children: [
            // Main content based on state
            BlocConsumer<ScannerBloc, ScannerState>(
              listener: _onStateChange,
              builder: (context, state) => _buildStateUI(state),
            ),
            // Bottom bar (always visible except during processing/error)
            BlocBuilder<ScannerBloc, ScannerState>(
              builder: (context, state) {
                if (state is ScannerProcessing ||
                    state is ScannerError ||
                    state is ScannerResult) {
                  return const SizedBox.shrink();
                }

                final markersDetected = switch (state) {
                  ScannerPreviewing(:final markersDetected) => markersDetected,
                  ScannerAligning(:final markersDetected) => markersDetected,
                  _ => 0,
                };

                return Positioned(
                  left: 0,
                  right: 0,
                  bottom: 0,
                  child: ScanBottomBar(
                    scannedCount: _scannedCount,
                    canCapture: markersDetected == 4,
                    onManualCapture: markersDetected == 4
                        ? () => _triggerManualCapture(context)
                        : null,
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStateUI(ScannerState state) {
    return switch (state) {
      ScannerIdle() || ScannerInitializing() => _buildInitializingView(),
      ScannerPreviewing(:final markersDetected, :final avgConfidence) =>
        _buildPreviewingView(markersDetected, avgConfidence, false, 0),
      ScannerAligning(:final markersDetected, :final avgConfidence, :final stabilityMs) =>
        _buildPreviewingView(markersDetected, avgConfidence, true, stabilityMs),
      ScannerCapturing() => _buildCapturingView(),
      ScannerProcessing(:final status) => _buildProcessingView(status),
      ScannerResult(:final scanResult, :final processingTimeMs) =>
        _buildResultView(scanResult, processingTimeMs),
      ScannerError(:final message, :final type) => _buildErrorView(message, type),
    };
  }

  Widget _buildInitializingView() {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(color: Colors.white),
          const SizedBox(height: 16),
          Text(
            'Initializing camera...',
            style: GoogleFonts.dmSans(
              fontSize: 14,
              color: Colors.white70,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPreviewingView(
    int markersDetected,
    double avgConfidence,
    bool isAligning,
    int stabilityMs,
  ) {
    final cameraService = getIt<CameraService>();

    return Stack(
      fit: StackFit.expand,
      children: [
        // Camera preview
        if (cameraService.isInitialized && cameraService.controller != null)
          CameraPreview(cameraService.controller!)
        else
          Container(color: Colors.black),

        // Alignment overlay
        AlignmentOverlay(
          markersDetected: markersDetected,
          isAligning: isAligning,
          stabilityMs: stabilityMs,
        ),
      ],
    );
  }

  Widget _buildCapturingView() {
    // Show frozen preview with shutter animation
    final cameraService = getIt<CameraService>();

    return Stack(
      fit: StackFit.expand,
      children: [
        if (cameraService.controller != null)
          CameraPreview(cameraService.controller!),
        // White flash overlay
        TweenAnimationBuilder<double>(
          tween: Tween(begin: 0.0, end: 1.0),
          duration: const Duration(milliseconds: 100),
          builder: (context, value, child) {
            return Container(
              color: Colors.white.withOpacity(value * 0.8),
            );
          },
          onEnd: () {
            // Trigger haptic feedback
            HapticFeedback.mediumImpact();
          },
        ),
      ],
    );
  }

  Widget _buildProcessingView(String status) {
    final cameraService = getIt<CameraService>();

    return Stack(
      fit: StackFit.expand,
      children: [
        // Dimmed camera preview
        if (cameraService.controller != null)
          ColorFiltered(
            colorFilter: ColorFilter.mode(
              Colors.black.withOpacity(0.3),
              BlendMode.darken,
            ),
            child: CameraPreview(cameraService.controller!),
          ),
        // Processing overlay
        ProcessingOverlay(status: status),
      ],
    );
  }

  Widget _buildResultView(ScanResult scanResult, int processingTimeMs) {
    // Result popup is shown via listener, return dimmed preview
    final cameraService = getIt<CameraService>();

    return Stack(
      fit: StackFit.expand,
      children: [
        if (cameraService.controller != null)
          ColorFiltered(
            colorFilter: ColorFilter.mode(
              Colors.black.withOpacity(0.5),
              BlendMode.darken,
            ),
            child: CameraPreview(cameraService.controller!),
          ),
      ],
    );
  }

  Widget _buildErrorView(String message, ScannerErrorType type) {
    final colorScheme = Theme.of(context).colorScheme;

    return Container(
      color: Colors.black87,
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 80,
                height: 80,
                decoration: BoxDecoration(
                  color: const Color(0xFFFF6B6B).withOpacity(0.2),
                  borderRadius: BorderRadius.circular(20),
                ),
                child: const Icon(
                  Icons.error_outline,
                  size: 40,
                  color: Color(0xFFFF6B6B),
                ),
              ),
              const SizedBox(height: 24),
              Text(
                _getErrorTitle(type),
                style: GoogleFonts.outfit(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                message,
                style: GoogleFonts.dmSans(
                  fontSize: 14,
                  color: Colors.white70,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              FilledButton.icon(
                onPressed: () {
                  context.read<ScannerBloc>().add(const ScannerRetryRequested());
                },
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
                style: FilledButton.styleFrom(
                  backgroundColor: const Color(0xFF0D7377),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _getErrorTitle(ScannerErrorType type) {
    return switch (type) {
      ScannerErrorType.cameraInitialization => 'Camera Error',
      ScannerErrorType.markerDetection => 'Markers Not Found',
      ScannerErrorType.imageCapture => 'Capture Failed',
      ScannerErrorType.omrProcessing => 'Processing Error',
      ScannerErrorType.grading => 'Grading Error',
      ScannerErrorType.persistence => 'Save Error',
    };
  }

  void _onStateChange(BuildContext context, ScannerState state) {
    if (state is ScannerResult) {
      _scannedCount++;
      _showResultPopup(context, state);
    }
  }

  void _showResultPopup(BuildContext context, ScannerResult state) {
    showModalBottomSheet(
      context: context,
      isDismissible: false,
      enableDrag: false,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (_) => ScanResultPopup(
        scanResult: state.scanResult,
        processingTimeMs: state.processingTimeMs,
        onContinue: () {
          Navigator.pop(context);
          context.read<ScannerBloc>().add(const ScannerResultDismissed());
        },
        onViewDetails: () {
          Navigator.pop(context);
          Navigator.pushNamed(
            context,
            AppRoutes.scanResultDetail,
            arguments: ScanResultDetailArgs(scanResult: state.scanResult),
          );
        },
      ),
    );
  }

  Future<bool> _onWillPop() async {
    final state = context.read<ScannerBloc>().state;

    if (state is ScannerProcessing) {
      // Show confirmation dialog
      final result = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text('Exit Scanner?', style: GoogleFonts.outfit()),
          content: Text(
            'Processing is still in progress. Are you sure you want to exit?',
            style: GoogleFonts.dmSans(),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: const Text('Exit'),
            ),
          ],
        ),
      );
      return result ?? false;
    }

    return true;
  }

  void _triggerManualCapture(BuildContext context) {
    // Manual capture triggers stability achieved immediately
    context.read<ScannerBloc>().add(const ScannerStabilityAchieved());
  }

  Future<void> _toggleFlash() async {
    final cameraService = getIt<CameraService>();
    final newMode = _flashOn ? FlashMode.off : FlashMode.torch;

    try {
      await cameraService.controller?.setFlashMode(newMode);
      setState(() => _flashOn = !_flashOn);
    } catch (e) {
      // Flash not available
      debugPrint('Flash toggle error: $e');
    }
  }
}

class _FlashToggleButton extends StatelessWidget {
  final bool isOn;
  final VoidCallback onToggle;

  const _FlashToggleButton({
    required this.isOn,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: Icon(isOn ? Icons.flash_on : Icons.flash_off),
      tooltip: isOn ? 'Turn off flash' : 'Turn on flash',
      onPressed: onToggle,
    );
  }
}

class _ErrorScaffold extends StatelessWidget {
  final String message;

  const _ErrorScaffold({required this.message});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Error')),
      body: Center(child: Text(message)),
    );
  }
}
```

---

### Step 7: Flash Toggle Implementation

Already included in Step 6. Key points:
- Uses `CameraController.setFlashMode()`
- Toggles between `FlashMode.off` and `FlashMode.torch`
- Only shown during Previewing/Aligning states
- Wrapped in try-catch for devices without flash

---

### Step 8: Update QuizMenuPage Navigation

**File:** `lib/features/quiz/presentation/pages/quiz_menu_page.dart`

Find the "Scan Papers" menu tile and update its onTap:

```dart
// Before
_MenuTile(
  icon: Icons.camera_alt,
  title: 'Scan Papers',
  subtitle: 'Scan student answer sheets',
  iconColor: Colors.blue,
  onTap: () {
    Navigator.pushNamed(
      context,
      AppRoutes.scanPapers,
      arguments: ScanPapersArgs(
        quizId: widget.args.quiz.id,
        quizName: widget.args.quiz.name,
      ),
    );
  },
),

// After
_MenuTile(
  icon: Icons.camera_alt,
  title: 'Scan Papers',
  subtitle: 'Scan student answer sheets',
  iconColor: const Color(0xFF0D7377),  // Match primary teal
  onTap: () {
    Navigator.pushNamed(
      context,
      AppRoutes.scanPapers,
      arguments: ScanPapersArgs(quiz: widget.args.quiz),  // Pass full Quiz
    );
  },
),
```

---

## Design Specifications Summary

### Colors (from quizzio-flutter-design skill)
```dart
const primaryTeal = Color(0xFF0D7377);        // Primary actions, capture button
const warmCoral = Color(0xFFFF6B6B);          // Not detected, errors
const softMint = Color(0xFF4ECDC4);           // Detected, success
const aligningGreen = Color(0xFF2ECC71);      // All aligned
```

### Typography
```dart
// Headers
GoogleFonts.outfit(fontSize: 20-24, fontWeight: FontWeight.w600)

// Body
GoogleFonts.dmSans(fontSize: 14-16)

// Status text (white on dark)
GoogleFonts.dmSans(fontSize: 16, color: Colors.white)
```

### Animation Timings
| Animation | Duration | Curve |
|-----------|----------|-------|
| Corner pulse | 600ms | easeInOut |
| Color transition | 200ms | easeOutCubic |
| Shutter flash | 100ms in, 100ms out | linear |
| Processing overlay | 300ms | easeOutCubic |
| Bottom sheet | 250ms | default |

### Touch Targets
- Capture button: 64dp (exceeds 48dp minimum)
- Flash toggle: 48dp (standard IconButton)
- Continue/View buttons: Full width, 48dp height

### Haptic Feedback
- `HapticFeedback.mediumImpact()` on capture

---

## Lifecycle Management

### WidgetsBindingObserver
- Monitor app lifecycle (paused/resumed)
- Camera cleanup handled by ScannerBloc

### WillPopScope
- Intercept back navigation during processing
- Show confirmation dialog if needed

### BLoC Auto-Disposal
- BlocProvider automatically closes ScannerBloc
- ScannerBloc.close() handles all resource cleanup

---

## Accessibility Considerations

### Semantic Labels
```dart
Semantics(
  label: markersDetected == 4
    ? 'All 4 corner markers detected. Hold steady.'
    : '$markersDetected of 4 corner markers detected.',
  child: AlignmentOverlay(...),
)
```

### Screen Reader Announcements
```dart
SemanticsService.announce(
  'Scan complete. Score: ${result.score} out of ${result.total}',
  TextDirection.ltr,
);
```

### Motion Preferences
```dart
final reduceMotion = MediaQuery.of(context).disableAnimations;
if (reduceMotion) {
  // Skip pulse animations
}
```

---

## Testing Checklist

- [ ] Camera initializes correctly on iOS
- [ ] Camera initializes correctly on Android
- [ ] Marker detection updates corner colors (0-4 markers)
- [ ] Pulsing animation works for undetected corners
- [ ] Stability timer triggers auto-capture after 500ms
- [ ] Manual capture button works when all markers detected
- [ ] Manual capture button disabled when < 4 markers
- [ ] Flash toggle works (on devices with flash)
- [ ] Processing overlay shows correct status messages
- [ ] Shutter animation and haptic feedback on capture
- [ ] Result popup displays score correctly
- [ ] "Continue Scanning" returns to preview
- [ ] "View Details" navigates to detail page
- [ ] Scanned count increments after each scan
- [ ] Error state shows appropriate message
- [ ] Retry button re-initializes scanner
- [ ] Back navigation works correctly
- [ ] Exit confirmation during processing
- [ ] App backgrounding doesn't crash
- [ ] App resuming works correctly

---

## Sub-task Breakdown (matches Development Plan)

- [ ] 4.2.1 Create `scan_papers_page.dart` with BlocProvider structure
- [ ] 4.2.2 Implement AppBar with back button and flash toggle
- [ ] 4.2.3 Implement BlocBuilder/BlocConsumer with state pattern matching
- [ ] 4.2.4 Create AlignmentOverlay widget (Previewing/Aligning states)
- [ ] 4.2.5 Create ProcessingOverlay widget
- [ ] 4.2.6 Create ScanResultPopup placeholder (Result state)
- [ ] 4.2.7 Create error view with retry button
- [ ] 4.2.8 Create ScanBottomBar with scan count and capture button
